## 03.설계 개선하기

현재의 코드를 이해하기 어려운 이유는 Theater가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. <br>
Theater가 Audience와 TicketSeller에 결합된다는 것을 의미한다.

이것은 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다.

Theater가 Audience와 TicketSeller에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다.
Theater가 원하는 것은 관람객이 소극장에 입장하는 것뿐이다.

따라서 관람객이 스스로 가방 안의 현금과 초대장을 처리하고 판매원이 스스로 매표소의 티켓과 판매 요금을 다루게 한다면 이 모든 문제를 한 번에 해결할 수 있을 것이다.

관람객과 판매원을 자율적인 존재로 만들자.

<br>

### 자율성을 높이자

1. Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 의 sellTo 메서드로 옮겨준다.
2. TicketSeller 클래스에서 getTicketOffice 메서드를 제거한다.
    - ticketOffice에 대한 접근은 오직 TicketSeller에서만 가능하도록 만들어 ticketSeller는 ticketOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행할 수 밖에 없다.
    - 개념적으로나 물리적으로 객체 내부의 세부사항을 감추는 것을 `캡슐화`라고 부른다.
    - 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.

Theater 클래스에 enter 메서드에 sellTo 메서드를 추가한다.

Theater는 ticketOffice가 ticketSeller 내부에 존재한다는 사실을 알지 못한다. Theater는 단지 ticketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

Audience의 buy 메서드를 추가하여 관람객이 직접 ticket의 소지 여부를 확인하고 비용을 지불하게 만들어준다.
- 캡슐화를 한다.

캡슐화 후의 달라진 점은 Audience와 TicketSeller가 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결한다는 것이다.

<br>

### 무엇이 개선되었나

Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어진다.

<br>

### 어떻게 한 것인가

수정하기 전 코드와 수정 후의 코드를 비교한다. 객체의 자율성을 높이는 방향으로 설계를 개선했다.

<br>

### 캡슐화와 응집도

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위힘하는 객체를 가리켜 `응집도`가 높다고 한다.

<br>

### 절차지향과 객체지향

프로세스
```
Theater의 enter 메서드
```

데이터
```
Audience, TicketSeller, Bag, TicketOffice
```

절차적 프로그래밍
```
프로세스와 데이터를 별도의 모듈에 위치시키는 방식
모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행한다.
```

객체지향 프로그래밍
```
데이터와 프로세스가 동일한 모듈 내부에 위하도록 프로그래밍하는 방식
```

<br>

### 책임의 이동

각 객체는 자신을 스스로 책임진다.

설계를 어렵게 만드는 것은 `의존성`

불필요한 의존성을 제거함으로써 객체 사이의 `결합도`를 낮추는 것

불필요한 세부사항을 객체 내부로 `캡슐화`하는 것은 객체의 `자율성`을 높이고 `응집도` 높은 객체들의 공동체를 창조할 수 있게 한다.

<br>